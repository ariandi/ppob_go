// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.14.0
// source: partners.sql

package db

import (
	"context"
	"database/sql"
)

const createPartner = `-- name: CreatePartner :one
INSERT INTO "partners" (
    name, "user", secret, add_info1, add_info2, valid_from, valid_to, payment_type, status,
    created_by, created_at
) values (
             $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, now()
         ) RETURNING id, name, "user", secret, add_info1, add_info2, valid_from, valid_to, payment_type, status, created_at, updated_at, deleted_at, created_by, updated_by, deleted_by
`

type CreatePartnerParams struct {
	Name        string        `json:"name"`
	User        string        `json:"user"`
	Secret      string        `json:"secret"`
	AddInfo1    string        `json:"add_info1"`
	AddInfo2    string        `json:"add_info2"`
	ValidFrom   sql.NullTime  `json:"valid_from"`
	ValidTo     sql.NullTime  `json:"valid_to"`
	PaymentType string        `json:"payment_type"`
	Status      string        `json:"status"`
	CreatedBy   sql.NullInt64 `json:"created_by"`
}

func (q *Queries) CreatePartner(ctx context.Context, arg CreatePartnerParams) (Partner, error) {
	row := q.db.QueryRowContext(ctx, createPartner,
		arg.Name,
		arg.User,
		arg.Secret,
		arg.AddInfo1,
		arg.AddInfo2,
		arg.ValidFrom,
		arg.ValidTo,
		arg.PaymentType,
		arg.Status,
		arg.CreatedBy,
	)
	var i Partner
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.User,
		&i.Secret,
		&i.AddInfo1,
		&i.AddInfo2,
		&i.ValidFrom,
		&i.ValidTo,
		&i.PaymentType,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.DeletedBy,
	)
	return i, err
}

const deletePartner = `-- name: DeletePartner :exec
DELETE FROM "partners"
WHERE id = $1
`

func (q *Queries) DeletePartner(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deletePartner, id)
	return err
}

const getPartner = `-- name: GetPartner :one
SELECT id, name, "user", secret, add_info1, add_info2, valid_from, valid_to, payment_type, status, created_at, updated_at, deleted_at, created_by, updated_by, deleted_by FROM "partners"
WHERE id = $1 AND deleted_at is null LIMIT 1
`

func (q *Queries) GetPartner(ctx context.Context, id int64) (Partner, error) {
	row := q.db.QueryRowContext(ctx, getPartner, id)
	var i Partner
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.User,
		&i.Secret,
		&i.AddInfo1,
		&i.AddInfo2,
		&i.ValidFrom,
		&i.ValidTo,
		&i.PaymentType,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.DeletedBy,
	)
	return i, err
}

const listPartner = `-- name: ListPartner :many
SELECT id, name, "user", secret, add_info1, add_info2, valid_from, valid_to, payment_type, status, created_at, updated_at, deleted_at, created_by, updated_by, deleted_by FROM "partners"
WHERE deleted_at is null
ORDER BY name
LIMIT $1
OFFSET $2
`

type ListPartnerParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListPartner(ctx context.Context, arg ListPartnerParams) ([]Partner, error) {
	rows, err := q.db.QueryContext(ctx, listPartner, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Partner{}
	for rows.Next() {
		var i Partner
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.User,
			&i.Secret,
			&i.AddInfo1,
			&i.AddInfo2,
			&i.ValidFrom,
			&i.ValidTo,
			&i.PaymentType,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.DeletedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateInactivePartner = `-- name: UpdateInactivePartner :one
UPDATE "partners" SET deleted_by = $2, deleted_at = now() WHERE id = $1
RETURNING id, name, "user", secret, add_info1, add_info2, valid_from, valid_to, payment_type, status, created_at, updated_at, deleted_at, created_by, updated_by, deleted_by
`

type UpdateInactivePartnerParams struct {
	ID        int64         `json:"id"`
	DeletedBy sql.NullInt64 `json:"deleted_by"`
}

func (q *Queries) UpdateInactivePartner(ctx context.Context, arg UpdateInactivePartnerParams) (Partner, error) {
	row := q.db.QueryRowContext(ctx, updateInactivePartner, arg.ID, arg.DeletedBy)
	var i Partner
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.User,
		&i.Secret,
		&i.AddInfo1,
		&i.AddInfo2,
		&i.ValidFrom,
		&i.ValidTo,
		&i.PaymentType,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.DeletedBy,
	)
	return i, err
}

const updatePartner = `-- name: UpdatePartner :one
UPDATE "partners"
SET
    "name" = CASE
            WHEN $1::bool
                THEN $2
            ELSE name
            END,
    "user" = CASE
               WHEN $3::bool
                THEN $4
               ELSE "user"
        END,
    secret = CASE
                 WHEN $5::bool
                    THEN $6
                 ELSE secret
        END,
    add_info1 = CASE
                 WHEN $7::bool
                    THEN $8
                 ELSE add_info1
        END,
    add_info2 = CASE
                    WHEN $9::bool
                    THEN $10
                    ELSE add_info2
        END,
    valid_from = CASE
                    WHEN $11::bool
                    THEN $12
                    ELSE valid_from
        END,
    valid_to = CASE
                     WHEN $13::bool
                    THEN $14
                     ELSE valid_to
        END,
    payment_type = CASE
                   WHEN $15::bool
                    THEN $16
                   ELSE payment_type
        END,
    status = CASE
                      WHEN $17::bool
                    THEN $18
                      ELSE status
        END,
    updated_by = $19,
    updated_at = now()
WHERE
    id = $20
RETURNING id, name, "user", secret, add_info1, add_info2, valid_from, valid_to, payment_type, status, created_at, updated_at, deleted_at, created_by, updated_by, deleted_by
`

type UpdatePartnerParams struct {
	SetName        bool          `json:"set_name"`
	Name           string        `json:"name"`
	SetUser        bool          `json:"set_user"`
	UserParams     string        `json:"user_params"`
	SetSecret      bool          `json:"set_secret"`
	Secret         string        `json:"secret"`
	SetAddInfo1    bool          `json:"set_add_info1"`
	AddInfo1       string        `json:"add_info1"`
	SetAddInfo2    bool          `json:"set_add_info2"`
	AddInfo2       string        `json:"add_info2"`
	SetValidFrom   bool          `json:"set_valid_from"`
	ValidFrom      sql.NullTime  `json:"valid_from"`
	SetValidTo     bool          `json:"set_valid_to"`
	ValidTo        sql.NullTime  `json:"valid_to"`
	SetPaymentType bool          `json:"set_payment_type"`
	PaymentType    string        `json:"payment_type"`
	SetStatus      bool          `json:"set_status"`
	Status         string        `json:"status"`
	UpdatedBy      sql.NullInt64 `json:"updated_by"`
	ID             int64         `json:"id"`
}

func (q *Queries) UpdatePartner(ctx context.Context, arg UpdatePartnerParams) (Partner, error) {
	row := q.db.QueryRowContext(ctx, updatePartner,
		arg.SetName,
		arg.Name,
		arg.SetUser,
		arg.UserParams,
		arg.SetSecret,
		arg.Secret,
		arg.SetAddInfo1,
		arg.AddInfo1,
		arg.SetAddInfo2,
		arg.AddInfo2,
		arg.SetValidFrom,
		arg.ValidFrom,
		arg.SetValidTo,
		arg.ValidTo,
		arg.SetPaymentType,
		arg.PaymentType,
		arg.SetStatus,
		arg.Status,
		arg.UpdatedBy,
		arg.ID,
	)
	var i Partner
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.User,
		&i.Secret,
		&i.AddInfo1,
		&i.AddInfo2,
		&i.ValidFrom,
		&i.ValidTo,
		&i.PaymentType,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.DeletedBy,
	)
	return i, err
}
